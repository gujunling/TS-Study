export {} //将其作为模块使用，避免出现不必要的错误。

// --------------------- object -----------------------

// object表示一个 JS 对象，此时并没有对这个变量 a 进行任何限制，一般不会如此设置

let a: object
a = {
  name: '哈哈哈',
  age: 20,
  a: 3,
  b: 4
}

// -------------------------------{}对象中包含什么属性的类型声明------------------------------------

// {} 用来指定对象中可以包含哪些属性
/**
 *  语法： 对象名 : {属性名1：属性值,属性名2：属性值,属性名3?:属性值}
 *               此时的属性名3是可选的，设置不设置均可
 *
 *   如果需要设置对象中包含必须的某一个属性，后面的其他的属性不进行限制，有没有均可，属性名也不进行限制，可以使用下面的方式来设置
 *  语法：  对象名 : {必须的属性名1：属性值,必须的属性名2：属性值,可选的属性名3?:属性值, [propName:string]:any}
 *         该示例中属性名1和属性名2是必须的参数，属性名3是可选的参数，除了这几个参数之外，还可以设置其他的任何类型的属性（propName可以根据自己的需要自行设置，这个不进行限制）
 *  */
let b: { name: string; age: number; price?: number }
// b = {}  //此时在编译的时候会报错，因为必须要设置 name 和age 属性,不能少设置属性，也不能多设置属性
b = { name: '小小', age: 12 }
// b = { name: '小小', age: 12,sex:'男' }   //此时在编译的时候也会报错

let c: { name: string; age: number; [propName: string]: any }
c = { name: '哈哈哈哈', age: 26, a: 1, b: true, c: 'test' }

// [prop: string]: any 表示任意类型的属性，其中prop可以自行修改，不受限制
let d: { name: string; [prop: string]: any }
d = { name: '测试2', ha: '哈哈哈', qwe: 123, cv: true }

// ---------------------------------函数结构的类型声明---------------------------
let e: (a: number, b: number) => number

// 此时会默认的为函数的形参设置类型为上面我们定义的number类型，函数的返回值也会默认的设置为number类型，如果我们设置为其他类型，编译的时候会报错
// 函数的形参名（下方函数中的 n1 和n2 ）不进行限制，可以根据自己的喜好进行设置,但形参的数量必须符合上面设置的，不能多也不能少
e = function (n1, n2) {
  return n1 + n2
}

// -------------------------------- array -----------------------------------

/**
 * 数组的类型声明
 *
 * 语法：
 *       方式一： 数据类型[]
 *       方式二：Array<数据类型>
 *
 */

// string[] 表示字符串数组
let f: string[]
f = ['小王', '小明', 'xiaoxiao']

// number[] 表示数字类型的数组
let g: number[]
g = [123, 456, 789, 1111, 10.2325]

// Array<number> 表示数值类型的数组
let h: Array<number>
h = [123, 456, 110.124, 66]

// ----------------------------------- tuple 元组---------------------------------

/**
 *
 * 元组：就是固定长度的数组
 *
 * 语法： [类型1,类型2,类型3 ...]
 *
 */

let j: [string, string]
j = ['qwe', 'aaa']

// ------------------------------- enum  枚举 ----------------------------------
// 因为数据库中转存字符串相对来说会大一点，为了使存储的数据相对来说小一点，会选择对某一些范围较小且不易改变的会选择使用枚举
enum Gender {
  Male = 0,
  Female = 1
}

let t: { name: string; gender: Gender }

t = {
  name: '小王',
  gender: Gender.Male
}

console.log(t.gender === Gender.Male)

// --------------------------------- & 同时满足 ---------------------------------------

// & 表示同时满足

let s: { name: string } & { age: number }
s = { name: '小明', age: 26 }

// --------------------------------- 类型别名 ------------------------------------------
// 简化类型的使用，避免重复书写 长度较长的类型或者限制较大的类型
type myType = 1 | 2 | 3 | 4
let m: myType
let n: myType

m = 1
n = 3
